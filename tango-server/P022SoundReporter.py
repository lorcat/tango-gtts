#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        P022SoundReporter.py
#
#  Project :     Sound reporter for macro controlled user feedback
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      konstantin.glazyrin$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["P022SoundReporter", "P022SoundReporterClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(P022SoundReporter.additionnal_import) ENABLED START -----#

try:
    import tango as PyTango
except ImportError:
    import PyTango

import os
import sys
import threading
import queue
import time
import re
from google.cloud import texttospeech
import datetime
import subprocess
import tempfile
import copy
import json

class GoogleCloudTTS:
    """
    Simple function to call can
    """

    OUT_FOLDER = "voice"

    def __init__(self, binit=True):
        super().__init__()

        self.client = None
        self.voice = None

        if binit:
            self.client = texttospeech.TextToSpeechClient()
            self.voice = texttospeech.VoiceSelectionParams(
                                    language_code="en-US",
                                    name="en-US-Neural2-C",
                                    ssml_gender=texttospeech.SsmlVoiceGender.FEMALE,
                                )

        self._datafolder = os.path.join(os.path.dirname(__file__), self.OUT_FOLDER)

        try:
            os.makedirs(self._datafolder, exist_ok=True)
        except OSError:
            pass

    @property
    def datafolder(self):
        return self._datafolder

    def save(self, msg):
        """
        Saves a message speech synthesis into a file
        :param msg: str() - serves as a message and as a base for output file
        :return:
        """
        # string reporting the result
        res = []

        if self.client is None:
            res.append("Error: the google client is not set correctly")
            return res

        # Set the text input to be synthesized
        synthesis_input = texttospeech.SynthesisInput(text=msg)

        # Select the type of audio file you want returned
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.MP3
        )

        # Perform the text-to-speech request on the text input with the selected
        # voice parameters and audio file type
        response = self.client.synthesize_speech(
            request={
                "input": synthesis_input, "voice": self.voice, "audio_config": audio_config
            }
        )

        # prepare a filename based on text
        filename = self.msg2filename(msg)

        # The response's audio_content is binary.
        if not os.path.exists(filename):
            with open(filename, "wb") as out:
                # Write the response to the output file.
                out.write(response.audio_content)
                res.append(f'Audio content written to file:\n"{filename}"')
        else:
            res.append(f"File already exists:\n{filename}")

        return res

    def msg2filename(self, msg):
        """
        Returns a filename based on the text input
        :param msg:
        :return:
        """
        # remove unnecessary elements - keep only text for filenames
        premove = re.compile("[\.\,\-\+\`\'\"\!\?\.\=\@\#\$\%\^\&\*\~\`]", re.I)
        preplace = re.compile("[\s+]", re.I)
        res = re.sub(premove, "", msg)

        res = os.path.join(self._datafolder, f"{re.sub(preplace, '_', res)}.mp3".lower())
        res = res.replace("\\", "/")

        return res

class SpeeckWorker(threading.Thread):
    """
    Class looking for speech commands to occur
    """

    POLLING_DELAY = 0.5
    POLLING_STEP = 0.25

    MSG_QUIT = "quit"

    def __init__(self, playcmd: str, qmsg: queue.Queue, parent):
        super(SpeeckWorker, self).__init__()
        self.daemon = True

        # stop queue
        self._qstop = queue.Queue()

        # message queue
        self.qmsg = qmsg

        # parent instance for status updates
        self.parent = parent

        # command to play files
        self.playcmd = playcmd

        # google objects
        self.gtts = GoogleCloudTTS()

    def set_parent_status(self, msg):
        """
        Sets the tango server status message
        :param msg:
        :return:
        """

        try:
            dt = datetime.datetime.now()
            msg = "{:02}-{:02}-{:04} {:02}:{:02}:{:02} - {}".format(dt.day, dt.month, dt.year, dt.hour,
                                                                 dt.minute, dt.second, msg)
            if self.parent is not None:
                self.parent._set_status(str(msg))
        except AttributeError:
            pass

    def run(self):
        """
        Simple workload loop
        :return:
        """
        # do not start processing unless the play sound command exists
        try:
            btest = self.parent._get_state()
            if btest in (PyTango.DevState.FAULT,):
                return
        except AttributeError:
            return

        # start the message loop
        while True:
            ts = time.time()

            if self.test_quit():
                break

            self.workload()

            # check exit state with polling
            dt = time.time() - ts
            if dt < self.POLLING_DELAY:
                dt = self.POLLING_DELAY - dt

                nsteps = int(dt / self.POLLING_STEP)
                if nsteps > 0:
                    for i in range(nsteps):
                        time.sleep(self.POLLING_STEP)

                    if self.test_quit():
                        break

    def workload(self):
        """
        Actual workload - looks at the text, compares it with the existing file names,
        Downloads the file if absent and plays it
        :return:
        """
        texts = []

        # get all messages from the stack
        while True:
            try:
                text = self.qmsg.get(block=False)
                self.qmsg.task_done()
                texts.append(text)
            except queue.Empty:
                break

        # test a player
        blistplay = False
        lst_players = ["vlc",]
        for player in lst_players:
            if player in self.playcmd[0]:
                blistplay = True
                break

        # go through messages stacked in the queue and play them one after another
        fns = []
        for text in texts:
            # checks text content
            if isinstance(text, str):
                text = text.strip()

                if len(text) == 0:
                    return

                fn = self.gtts.msg2filename(text)
                if os.name == "nt":
                    fn = fn.replace("/", "\\")
                fns.append(fn)
                self.set_parent_status(f"Speech filename: {fn}:{os.path.exists(fn)}")

                # download the file if not existing - host should have access to internet
                if not os.path.exists(fn):
                    for tmsg in self.gtts.save(text):
                        self.set_parent_status(tmsg)

                # play sound immediately if player does not support listing or there is only one message
                if not blistplay or len(texts) < 2:
                    # play if the file exists (e.g. after a download)
                    if os.path.exists(fn):
                        self.play_sound(fn)

        # if player supports lists
        if blistplay and len(texts) > 1:
            tname = ""

            with tempfile.TemporaryFile(suffix=".m3u", mode="w+", delete=False, dir=self.gtts.datafolder) as fh:
                tname = fh.name
                fh.write("\n".join(fns))

            self.play_sound(tname)

            try:
                if os.path.exists(tname) and os.path.isfile(tname):
                    os.unlink(tname)
                    pass
            except (IOError, OSError):
                self.set_parent_status("Error: could not remove file ({})".format(tname))

    def test_quit(self):
        """
        Tests for stop thread condition
        :return:
        """
        res = False
        try:
            self._qstop.get(block=False)
            self._qstop.task_done()
            res = True
        except queue.Empty:
            pass

        return res

    def play_sound(self, filename):
        """
        Starts sound via a subprocess
        :return:
        """
        cmd = list(copy.copy(self.playcmd))

        if os.name == "nt":
            filename = filename.replace("/", "\\")

        cmd.append(filename)

        # print(cmd)
        try:
            sid = subprocess.run(cmd)
            print(f"Command executed: {sid}")
        except subprocess.CalledProcessError as e:
            try:
                self.parent.debug_stream(e)
            except AttributeError:
                pass

    def stop(self):
        """
        Stops the execution of the thread
        :return:
        """
        self._qstop.put(self.MSG_QUIT)

#----- PROTECTED REGION END -----#	//	P022SoundReporter.additionnal_import

# Device States Description
# No states for this device


class P022SoundReporter (PyTango.Device_4Impl):
    """"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(P022SoundReporter.global_variables) ENABLED START -----#
    GOOGLE_ENV = "GOOGLE_APPLICATION_CREDENTIALS"
    #----- PROTECTED REGION END -----#	//	P022SoundReporter.global_variables

    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        P022SoundReporter.init_device(self)
        #----- PROTECTED REGION ID(P022SoundReporter.__init__) ENABLED START -----#

        # locks for multithreaded operation
        self._status_lock = threading.Lock()
        self._state_lock = threading.Lock()

        # queue for commands
        self.qmsg = queue.Queue()

        # run tests for the initial parameters
        errmsg = []

        tstr = ["dummy"]
        try:
            tstr = json.loads(self.cmdplay)

            if not os.path.exists(tstr[0]):
                raise ValueError


        except json.JSONDecodeError:
            self._set_state(PyTango.DevState.FAULT)
            self._set_status("Error: Could not parse the (cmdplay) property as JSON string")
        except ValueError:
            self._set_state(PyTango.DevState.FAULT)
            errmsg.append("Error: Sound playing command does not exist:\n{}".format(self.cmdplay))

        self.cmdplay = copy.copy(tstr)

        env = os.environ
        if not self.GOOGLE_ENV in env:
            self.set_state(PyTango.DevState.FAULT)
            errmsg.append("Error: Google API key ({}) is not set".format(self.GOOGLE_ENV))

        # set state + status messages
        tstate = self._get_state()
        if tstate == PyTango.DevState.FAULT:
            self._set_status("\n".join(errmsg))
        else:
            self._set_state(PyTango.DevState.ON)
            self._set_status("Sound playing command:\n{}".format(self.cmdplay))

        self.worker = SpeeckWorker(playcmd=self.cmdplay, qmsg=self.qmsg, parent=self)
        self.worker.start()
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(P022SoundReporter.delete_device) ENABLED START -----#
        if isinstance(self.worker, SpeeckWorker) and self.worker.is_alive():
            self.worker.stop()
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        #----- PROTECTED REGION ID(P022SoundReporter.init_device) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(P022SoundReporter.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.always_executed_hook

    # -------------------------------------------------------------------------
    #    P022SoundReporter read/write attribute methods
    # -------------------------------------------------------------------------
    
    
    
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(P022SoundReporter.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.read_attr_hardware


    # -------------------------------------------------------------------------
    #    P022SoundReporter command methods
    # -------------------------------------------------------------------------
    
    def Speak(self, argin):
        """ 
        :param argin: 
            Speaks a text, if a file exists - it is played.
            Otherwise it is first downloaded from google and then played.
        :type argin: PyTango.DevString
        """
        self.debug_stream("In Speak()")
        #----- PROTECTED REGION ID(P022SoundReporter.Speak) ENABLED START -----#
        self.info_stream("Text to speak: ({})".format(argin))
        self.qmsg.put(argin)
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.Speak
        

    #----- PROTECTED REGION ID(P022SoundReporter.programmer_methods) ENABLED START -----#
    def _set_status(self, msg):
        """
        Sets the status in multi-threaded way
        :return:
        """
        with self._status_lock:
            print(msg)
            self.set_status(msg)

    def _set_state(self, state):
        """
        Sets the state in multithreaded way
        :param msg:
        :return:
        """
        with self._state_lock:
            self.set_state(state)

    def _get_state(self):
        """
        Returns the object state in multithreaded way
        :return:
        """
        res = PyTango.DevState.FAULT
        with self._state_lock:
            res = self.get_state()
        return res
    #----- PROTECTED REGION END -----#	//	P022SoundReporter.programmer_methods

class P022SoundReporterClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(P022SoundReporter.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	P022SoundReporter.global_class_variables


    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'cmdplay':
            [PyTango.DevString, 
            "Command used to play sound - json array as a string",
            ["['mpg321',]"] ],
        }


    #    Command definitions
    cmd_list = {
        'Speak':
            [[PyTango.DevString, "Speaks a text, if a file exists - it is played.\nOtherwise it is first downloaded from google and then played."],
            [PyTango.DevVoid, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(P022SoundReporterClass, P022SoundReporter, 'P022SoundReporter')
        #----- PROTECTED REGION ID(P022SoundReporter.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	P022SoundReporter.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)

if __name__ == '__main__':
    main()
